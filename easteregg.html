<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>üöÄ Mini Space Blaster</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #111827cc;
      --accent: #60a5fa;
      --good: #34d399;
      --bad: #f87171;
      --text: #e5e7eb;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 50% 20%, #0e1726 0%, #0b0f1a 60%, #090d15 100%);
      color: var(--text);
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }

    .wrap {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      gap: 8px;
      flex-wrap: wrap;
    }

    .title {
      font-weight: 700;
      letter-spacing: .3px;
      font-size: 18px;
    }

    .pill {
      background: var(--panel);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 14px;
    }

    .btn {
      appearance: none;
      border: 1px solid #1f2937;
      background: #0d1321;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
    }
    .btn:hover { filter: brightness(1.1); }
    .btn:active { transform: translateY(1px); }

    /* Canvas */
    .canvas-wrap {
      position: relative;
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px;
    }

    canvas {
      width: 100%;
      max-width: 800px;
      height: calc(100vh - 200px);
      max-height: 70vh;
      background: transparent;
      border: 1px solid #1f2937;
      border-radius: 12px;
      box-shadow: 0 10px 30px #0006;
    }

    /* Overlay */
    .overlay {
      position: absolute;
      inset: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #0b0f1aaa, #0b0f1acc);
      backdrop-filter: blur(6px);
      border-radius: 12px;
      padding: 20px;
      z-index: 5;
    }

    .card {
      max-width: 480px;
      width: 90%;
      background: #0d1423;
      border: 1px solid #1f2937;
      border-radius: 14px;
      padding: 18px 16px;
      text-align: center;
      box-shadow: 0 8px 30px #0008;
    }

    .card h1 {
      margin: 6px 0 10px;
      font-size: 20px;
    }

    .card p {
      margin: 0 0 14px;
      color: #cbd5e1;
      font-size: 15px;
    }

    /* Mobile controls (nur 2 Buttons) */
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      padding: 12px;
      z-index: 2;
      background: #0b0f1acc;
      backdrop-filter: blur(6px);
    }

    .ctrl {
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      background: #0d1321;
      border: 1px solid #1f2937;
      border-radius: 14px;
      padding: 18px 12px;
      text-align: center;
      font-weight: 700;
      font-size: 20px;
      color: var(--text);
    }

    .ctrl:active { transform: translateY(2px); }

    /* Desktop: hide controls */
    @media (hover: hover) and (pointer: fine) {
      .controls { display: none; }
    }

    @media (orientation: landscape) {
      canvas { height: 80vh; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">üöÄ Mini Space Blaster</div>
      <div class="stats">
        <div class="pill">Score: <span id="uiScore">0</span></div>
        <div class="pill">Leben: <span id="uiLives">3</span></div>
        <div class="pill">Level: <span id="uiLevel">1</span></div>
        <button class="btn" id="btnPause">Pause</button>
        <button class="btn" id="btnRestart">Neu</button>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="game" width="800" height="600" aria-label="Spielbereich"></canvas>
      <div id="overlay" class="overlay">
        <div class="card">
          <h1 id="ovTitle">Mini Space Blaster</h1>
          <p id="ovMsg">Steuere mit <span class="kbd">‚Üê</span> <span class="kbd">‚Üí</span> und feuere mit Tipp auf den Bildschirm!</p>
          <div style="margin-top:10px">
            <button id="ovStart" class="btn">Starten</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Nur 2 mobile Buttons -->
    <div class="controls">
      <button class="ctrl" id="btnLeft">‚óÄÔ∏é</button>
      <button class="ctrl" id="btnRight">‚ñ∂Ô∏é</button>
    </div>
  </div>

  <script>
  (function () {
    'use strict';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resizeCanvasToDisplaySize() {
      const cssWidth = canvas.clientWidth;
      const cssHeight = canvas.clientHeight;
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      const needResize = canvas.width !== Math.floor(cssWidth * dpr) || canvas.height !== Math.floor(cssHeight * dpr);
      if (needResize) {
        canvas.width = Math.floor(cssWidth * dpr);
        canvas.height = Math.floor(cssHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      return needResize;
    }
    resizeCanvasToDisplaySize();
    window.addEventListener('resize', resizeCanvasToDisplaySize);

    const state = {
      running: false,
      paused: false,
      score: 0,
      lives: 3,
      level: 1,
      time: 0,
      nextEnemyIn: 0,
      enemyInterval: 900,
      enemies: [],
      bullets: [],
      keys: { left: false, right: false, fire: false },
      lastShot: 0,
      shotCooldown: 180
    };

    const player = { x: 380, y: 540, w: 36, h: 16, speed: 300, color: '#60a5fa' };
    const rand = (min, max) => Math.random() * (max - min) + min;
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const rectsOverlap = (a, b) => a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

    // Keyboard
    window.addEventListener('keydown', e => {
      if (e.code === 'ArrowLeft') state.keys.left = true;
      if (e.code === 'ArrowRight') state.keys.right = true;
      if (e.code === 'Space') state.keys.fire = true;
    });
    window.addEventListener('keyup', e => {
      if (e.code === 'ArrowLeft') state.keys.left = false;
      if (e.code === 'ArrowRight') state.keys.right = false;
      if (e.code === 'Space') state.keys.fire = false;
    });

    // Touch buttons
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    function holdButton(btn, on, off) {
      const down = e => { on(); e.preventDefault(); };
      const up = e => { off(); e.preventDefault(); };
      btn.addEventListener('touchstart', down, { passive: false });
      btn.addEventListener('mousedown', down);
      window.addEventListener('touchend', up, { passive: false });
      window.addEventListener('mouseup', up);
      window.addEventListener('touchcancel', up, { passive: false });
    }

    holdButton(btnLeft, () => state.keys.left = true, () => state.keys.left = false);
    holdButton(btnRight, () => state.keys.right = true, () => state.keys.right = false);

    // --- Tap anywhere to shoot ---
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      state.keys.fire = true;
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      state.keys.fire = false;
    }, { passive: false });
    canvas.addEventListener('mousedown', e => state.keys.fire = true);
    canvas.addEventListener('mouseup', e => state.keys.fire = false);

    // UI elements
    const uiScore = document.getElementById('uiScore');
    const uiLives = document.getElementById('uiLives');
    const uiLevel = document.getElementById('uiLevel');
    const btnPause = document.getElementById('btnPause');
    const btnRestart = document.getElementById('btnRestart');
    const overlay = document.getElementById('overlay');
    const ovTitle = document.getElementById('ovTitle');
    const ovMsg = document.getElementById('ovMsg');
    const ovStart = document.getElementById('ovStart');

    function showOverlay(title, msg, startText = 'Starten') {
      ovTitle.textContent = title;
      ovMsg.innerHTML = msg;
      ovStart.textContent = startText;
      overlay.style.display = 'flex';
    }
    function hideOverlay() { overlay.style.display = 'none'; }

    function updateUI() {
      uiScore.textContent = state.score;
      uiLives.textContent = state.lives;
      uiLevel.textContent = state.level;
      btnPause.textContent = state.paused ? 'Fortsetzen' : 'Pause';
    }

    function startGame() {
      state.running = true;
      state.paused = false;
      state.score = 0;
      state.lives = 3;
      state.level = 1;
      state.time = 0;
      state.enemies = [];
      state.bullets = [];
      state.enemyInterval = 900;
      state.nextEnemyIn = 300;
      player.x = (canvas.clientWidth - player.w) / 2;
      player.y = canvas.clientHeight - 60;
      hideOverlay();
      updateUI();
      lastFrameTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      state.running = false;
      showOverlay('Game Over', `Score: <span class="score">${state.score}</span> ‚Äì Level: ${state.level}`, 'Nochmal');
    }

    function togglePause() {
      if (!state.running) return;
      state.paused = !state.paused;
      if (state.paused) {
        showOverlay('Pausiert', 'Dr√ºcke ‚ÄûFortsetzen‚Äú oder ‚ÄûP‚Äú, um weiterzuspielen.', 'Fortsetzen');
      } else {
        hideOverlay();
        lastFrameTime = performance.now();
        requestAnimationFrame(loop);
      }
      updateUI();
    }

    btnPause.addEventListener('click', togglePause);
    btnRestart.addEventListener('click', () => showOverlay('Neustart', 'Bereit?'));
    ovStart.addEventListener('click', startGame);

    function maybeLevelUp() {
      const thresholds = [20, 50, 100, 160, 230, 310, 400];
      const nextLevel = thresholds.findIndex(t => state.score < t) + 1 || thresholds.length + 1;
      if (nextLevel !== state.level) {
        state.level = nextLevel;
        state.enemyInterval = Math.max(350, 900 - (state.level - 1) * 80);
        updateUI();
      }
    }

    function spawnEnemy() {
      const w = rand(20, 45), h = rand(14, 30);
      const speed = Math.random() * w + 10 + state.level * h / state.shotCooldown;
      const x = Math.random() * (canvas.clientWidth - w);
      const y = -h - 2;
      const hp = Math.random() < Math.min(0.15 + state.level * 0.03, 0.6) ? 2 : 1;
      state.enemies.push({ x, y, w, h, vy: speed, hp, color: hp > 1 ? '#fbbf24' : '#9ca3af' });
    }

    function shoot() {
      const now = state.time;
      if (now - state.lastShot < state.shotCooldown) return;
      state.lastShot = now;
      const bw = 3, bh = 10;
      state.bullets.push({ x: player.x + player.w / 2 - bw / 2, y: player.y - bh, w: bw, h: bh, vy: -520 });
    }

    let lastFrameTime = performance.now();

    function loop(ts) {
      if (!state.running || state.paused) return;
      resizeCanvasToDisplaySize();
      const dt = Math.min(0.035, (ts - lastFrameTime) / 1000);
      lastFrameTime = ts;
      state.time += dt * 1000;

      let move = 0;
      if (state.keys.left) move -= 1;
      if (state.keys.right) move += 1;
      player.x += move * player.speed * dt;
      player.x = clamp(player.x, 0, canvas.clientWidth - player.w);

      if (state.keys.fire) shoot();

      state.nextEnemyIn -= dt * 1000;
      if (state.nextEnemyIn <= 0) {
        spawnEnemy();
        state.nextEnemyIn = state.enemyInterval * (0.6 + Math.random() * 0.8);
      }

      // Bullets
      for (let i = state.bullets.length - 1; i >= 0; i--) {
        const b = state.bullets[i];
        b.y += b.vy * dt;
        if (b.y + b.h < -20) state.bullets.splice(i, 1);
      }

      // Enemies
      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        e.y += e.vy * dt;
        if (rectsOverlap(e, player)) {
          state.enemies.splice(i, 1);
          state.lives -= 1;
          if (state.lives <= 0) { updateUI(); draw(); return gameOver(); }
          updateUI();
          continue;
        }
        if (e.y > canvas.clientHeight + 10) {
          state.enemies.splice(i, 1);
          state.lives -= 1;
          if (state.lives <= 0) { updateUI(); draw(); return gameOver(); }
          updateUI();
        }
      }

      // Collisions
      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        for (let j = state.bullets.length - 1; j >= 0; j--) {
          const b = state.bullets[j];
          if (rectsOverlap(e, b)) {
            state.bullets.splice(j, 1);
            e.hp -= 1;
            if (e.hp <= 0) {
              state.enemies.splice(i, 1);
              state.score += 5;
              maybeLevelUp();
            } else e.color = '#fca5a5';
            break;
          }
        }
      }

      draw();
      requestAnimationFrame(loop);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      drawStars();

      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.fillRect(player.x + player.w * 0.4, player.y - 6, player.w * 0.2, 6);

      ctx.fillStyle = '#e5e7eb';
      for (const b of state.bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

      for (const e of state.enemies) {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x, e.y, e.w, e.h);
        if (e.hp > 1) {
          ctx.fillStyle = '#ef4444';
          ctx.fillRect(e.x, e.y - 3, e.w, 2);
        }
      }
    }

    let starSeed = 0;
    function drawStars() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      starSeed += 0.2;
      ctx.globalAlpha = 0.9;
      for (let i = 0; i < 90; i++) {
        const x = (i * 97 + starSeed * 3) % w;
        const y = (i * 53 + starSeed * 5) % h;
        const r = (i % 3 === 0) ? 1.6 : 1;
        ctx.fillStyle = i % 9 === 0 ? '#ffffff' : '#cbd5e17a';
        ctx.fillRect(x, y, r, r);
      }
      ctx.globalAlpha = 1;
    }

    showOverlay(
      'Mini Space Blaster',
      'Steuere mit <span class="kbd">‚Üê</span> <span class="kbd">‚Üí</span> oder den Buttons unten ‚Äì schie√üe durch Tippen auf den Bildschirm!',
      'Starten'
    );
    updateUI();
  })();
  </script>
</body>
</html>
